#pragma config(Sensor, in3,    clawa,          sensorPotentiometer)
#pragma config(Sensor, in4,    clawb,          sensorPotentiometer)
#pragma config(Sensor, dgtl1,  armShaft,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  driveLeftShaft, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  driveRightShaft, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  clawShaft,      sensorQuadEncoder)
#pragma config(Motor,  port1,           R_one,         tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           R_two,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           R_Y,           tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           L_two,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           L_Y,           tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           Claw1,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           Claw2,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           DL1,           tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port9,           DR1,           tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          L_one,         tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

//controls

/*
channel 1 and channel 2 - drive
channel 3 - arms
channel 4 - manual claw
button 7U - enable manual claw
button 6U - claw close
button 5U - claw open



*/

//global integers

int claw = SensorValue[in3];
int x_axis, y_axis;
float a_value = 0.000062;
int lift;
int claw_l, claw_r;
int claw_d_l;
int claw_d_r;
int claw1_power;
int claw2_power;
int claw_r_i;
int claw_l_i;

task driving()
{
	while(true)
	{
		x_axis = (a_value * (vexRT[Ch1]* vexRT[Ch1]* vexRT[Ch1]));
		y_axis = (a_value * (vexRT[Ch2]* vexRT[Ch2]* vexRT[Ch2]));
		lift = vexRT[Ch3];

		motor[DL1] = (y_axis - x_axis);
		motor[DR1] = (y_axis + x_axis);
		motor[L_one] = lift;
		motor[L_two] = lift;
		motor[L_Y] = lift;
		motor[R_one] = lift;
		motor[R_two] = lift;
		motor[R_Y] = lift;
	}
}

task claw_d()
{
	claw_r = SensorValue[in3] + 400;
	claw_l = SensorValue[in4] + 0;
	int claw_r_save;
	int claw_l_save;
	while(true)
	{
		claw_r_save = claw_r;
		claw_l_save = claw_l;
		wait1Msec(100);
		claw_d_r = claw_r - claw_r_save;
		claw_d_l = claw_l - claw_l_save;
	}
}

task claw_()
{
	startTask(claw_d);
	//startTask(claw_i);

	claw_r = SensorValue[in3] + 400;
	claw_l = SensorValue[in4] + 0;

	while(true)
	{


		if(vexRT[Btn5U] == 1)
		{
			claw = 1440;
		}
		if(vexRT[Btn6U] == 1)
		{
			claw = 2520;
		}



		if(vexRT[Btn7U] == 0)
		{
			motor[Claw1] = (claw - claw_r)*0.2 + /*claw_r_i*0.000*/ - claw_d_r*0.04;
			motor[Claw2] = (claw - claw_l)*0.2 + /*claw_r_i*0.000*/  - claw_d_l*0.04 ;
		}
		else if(vexRT[Btn7U] == 1)
		{
			motor[Claw1] = vexRT[Ch4];
			motor[Claw2] = vexRT[Ch4];
		}
	}
}


void pre_auton()
 {	
 	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	bDisplayCompetitionStatusOnLcd = false;
	clearLCDLine(0);                      // Clear line 1 (0) of the LCD
	clearLCDLine(1);                      // Clear line 2 (1) of the LCD
	bLCDBacklight = true;
	startTask(LCD);



	SensorValue[in1] = 0;

task gyro_direction
{
	int x = false;
	while(true)
	{
		if(motor[DL1] > 0 && x == false )
		{
			turns++;
			x = true;
		}
		else if(motor[DL1] < 0 && x == true)
		{
			turns++;
			x = false;
		}
	}
}

void gyro_turn(int angle)
{
	int motorpower = 1;
	bool turned = false;
	i = 1;
	int tol_gyro = 20;
	int counter_g;
	bool a = true;
	bool turn_count = true;
	turns = 0;
	SensorValue[in2] = sensorNone;

	while(turned == false)
	{

		if(SensorValue[in2] > angle - tol_gyro && SensorValue[in2] < angle + tol_gyro)
		{
			turns = 0;
			i = 1;
			motorpower = 0;
			turned = true;
		}
		if(motorpower < 0 && a == true)
		{
			turns++;
			a = false;
		}
		else if(motorpower > 0 && a == false)
		{
			turns++;
			a = true;
		}
		if(turns == 0)
		{
			motorpower = (SensorValue[GYRO] - angle)*2;
		}
		else
		{
			motorpower = (SensorValue[GYRO] - angle)/(turns*2.5);
		}
		motor[DR1] = motorpower + motorpower*(i/800);
		motor[DL1] = -motorpower - motorpower * (i/800);


	}
}

void drive(int dist)
{
	bool drive_a_ = true;
	SensorValue[left_sensor] = 0;
	SensorValue[right_sensor] = 0;
	int tol_da = 25;
	//while(drive_a_ == true)
	//{

	//	bool kill_loop = false;
	//	bool kill_loop_r = false;

	//	if(dist + tol_da > SensorValue[left_sensor] && dist - tol_da < SensorValue[left_sensor] && kill_loop == false)
	//	{
	//		wait10Msec(5);
	//		kill_loop = true;
	//		motor[DL1] = 0 ;
	//		motor[DL2] = 0;
	//	}
	//	else if((SensorValue[left_sensor]) < dist)
	//	{
	//		motor[DL1] = -speed;
	//		motor[DL2] = -speed;
	//	}
	//	else if((SensorValue[left_sensor]) > dist)
	//	{
	//		motor[DL1] = speed;
	//		motor[DL2] = speed;
	//	}
	//	if(dist + tol_da > SensorValue[right_sensor] && dist - tol_da < SensorValue[right_sensor] && kill_loop_r == false)
	//	{
	//		wait10Msec(5);
	//		kill_loop_r = true;
	//		motor[DR1] = 0;
	//		motor[DR2] = 0;
	//	}
	//	else if((SensorValue[right_sensor]) < dist)
	//	{
	//		motor[DR1] = -speed;
	//		motor[DR2] = -speed;
	//	}
	//	else if((SensorValue[right_sensor]) > dist)
	//	{
	//		motor[DR1] = speed;
	//		motor[DR2] = speed;
	//	}
	//	if(kill_loop == true && kill_loop_r == true)
	//	{
	//		drive_a_ = false;
	//	}
	//}
	int counter_d = 0;
	int counter_d_2 = 0;

	while(drive_a_ == true)
	{



		if(dist == -400)
		{
			SensorValue[dgtl10] = 1;
		}
		else
		{
			SensorValue[dgtl10] = 0;
		}
		if(counter_d > 150)
		{
			motor[DL1] = 0;
			motor[DR1] = 0;

			drive_a_ = false;

		}
		if(dist + tol_da > SensorValue[left_sensor] && dist - tol_da < SensorValue[left_sensor])
		{
			counter_d ++;
			counter_d_2 = 0;
		}

		else
		{
			counter_d_2 ++;
			int motorpower;
			motorpower = (SensorValue[left_sensor] - dist)* 0.55;
			if(motorpower < tol_da && motorpower > -tol_da && motorpower != 0)
			{
				motorpower = 0;
			}
			motor[DL1] = motorpower + motorpower*(counter_d_2/200);

			motor[DR1] = motorpower + motorpower*(counter_d_2/200);

		}

	}
}

void shoot(int arms, int wait)
{
	bool arms_up = false;
	bool arms_returned = false;
	while(arms_returned == false)
	{
		if(SensorValue[arms_sensor] > arms && arms_up == false)
		{

			motor[L_one] = 0;
			motor[L_two] = 0;
			motor[L_Y] = 0;
			motor[R_one] = 0;
			motor[R_two] = 0;
			motor[R_Y] = 0;
			arms_up = true;
		}

		else if(SensorValue[arms_sensor] < arms && arms_up == false)
		{
			motor[L_one] = 127;
			motor[L_two] = 127;
			motor[L_Y] = 127;
			motor[R_one] = 127;
			motor[R_two] = 127;
			motor[R_Y] = 127;
		}
		if(SensorValue[arms_sensor] > 10 &&  arms_up == true)
		{
			wait10Msec(wait);
			motor[L_one] = 0;
			motor[L_two] = 0;
			motor[L_Y] = 0;
			motor[R_one] = 0;
			motor[R_two] = 0;
			motor[R_Y] = 0;
			arms_returned = true;
		}
		else if(SensorValue[arms_sensor] < 15 && arms_up == true)
		{
			motor[L_one] = 0;
			motor[L_two] = 0;
			motor[L_Y] = 0;
			motor[R_one] = 0;
			motor[R_two] = 0;
			motor[R_Y] = 0;
			arms_returned = true;
		}
	}
}
void deploy()
{
	motor[L_one] = 55;
	motor[L_two] = 55;
	motor[L_Y] = 55;
	motor[R_one] = 55;
	motor[R_two] = 55;
	motor[R_Y] = 55;
	wait10Msec(75);
	motor[L_one] = 0;
	motor[L_two] = 0;
	motor[L_Y] = 0;
	motor[R_one] = 0;
	motor[R_two] = 0;
	motor[R_Y] = 0;
	wait10Msec(20);
	motor[L_one] = -127;
	motor[L_two] = -127;
	motor[L_Y] = -127;
	motor[R_one] = -127;
	motor[R_two] = -127;
	motor[R_Y] = -127;
	wait10Msec(400);
	motor[L_one] = 0;
	motor[L_two] =0;
	motor[L_Y] = 0;
	motor[R_one] = 0;
	motor[R_two] = 0;
	motor[R_Y] = 0;
}
//void hold_arms_temp() //temp
//{
//	bool loopback = false;
//	while(loopback == false)
//	if(SensorValue[arms_sensor] > 50 && SensorValue[arms_sensor] < 60)
//	{
//		wait10Msec(10);
//		motor[L_one] = 0;
//		motor[L_two] = 0;
//		motor[L_Y] = 0;
//		motor[R_one] = 0;
//		motor[R_two] = 0;
//		motor[R_Y] = 0;
//		loopback = true;
//	}
//	if(SensorValue[arms_sensor] < 55)
//	{
//		motor[L_one] = 60;
//		motor[L_two] = 60;
//		motor[L_Y] = 60;
//		motor[R_one] = 60;
//		motor[R_two] = 60;
//		motor[R_Y] = 60;
//	}
//	else if (SensorValue[arms_sensor] > 55)
//	{
//		motor[L_one] = -30;
//		motor[L_two] = -30;
//		motor[L_Y] = -30;
//		motor[R_one] = -30;
//		motor[R_two] = -30;
//		motor[R_Y] = -30;
//	}

//}
void arm_down()
{
	motor[L_one] = -20;
	motor[L_two] = -20;
	motor[L_Y] = -20;
	motor[R_one] = -20;
	motor[R_two] = -20;
	motor[R_Y] = -20;
	wait10Msec(50);
	motor[L_one] = 0;
	motor[L_two] = 0;
	motor[L_Y] = 0;
	motor[R_one] = 0;
	motor[R_two] = 0;
	motor[R_Y] = 0;
}
task claw_task()
{
	while (true)
	{
		claw_r = SensorValue[in3];
		claw_l = SensorValue[in4];

		if(vexRT[Btn7R] == 1)
		{
			claw -= 2;

		}
		else if(vexRT[Btn7L] == 1)
		{
			claw += 2;

		}
		else if(vexRT[Btn6U] == 1)
		{
			claw = 1700;
		}
		else if(vexRT[Btn5U] == 1)
		{
			claw = 2800;
		}
		else
		{
			claw = claw;
		}

		motor[Claw1] = (claw - claw_r)/10;
		motor[Claw2] = (claw - claw_l)/10;
	}
}
task arms_PI()
{
	counter = 0;
	Lift_P = 0;
	SensorValue[arms_sensor] = 0;
	while(true)
	{

		while(arms_returned == true && hold == true)
		{
			//Liftx = (((40 - SensorValue[arms_sensor])*100)/ 40;
			Lift_P = (1.75 * (height - SensorValue[arms_sensor]));

			if(hold == true)
			{
				lift = (20+(Lift_P));
				counter ++;

			}
			if(counter > 500)
			{
				Lift_I += 1;
				counter = 0;
			}
			motor[L_one] = lift;
			motor[L_two] = lift;
			motor[L_Y] = lift;
			motor[R_one] = lift;
			motor[R_two] = lift;
			motor[R_Y] = lift;
		}

	}
}
task driver()
{
	while(true)
	{





		x_axis = ((a_value/1.5) * (vexRT[Ch1]* vexRT[Ch1]* vexRT[Ch1]));
		y_axis = (a_value * (vexRT[Ch2]* vexRT[Ch2]* vexRT[Ch2]));

		left_drive = (y_axis - x_axis); //converts x and y axis to left motor power
		right_drive = (y_axis + x_axis);
		motor[DL1] = left_drive;
		motor[DR1] = right_drive;

	}
}
task arms()
{
	while(true)
	{

		hold = false;
		arms_returned = false;
		lift = vexRT[Ch3];
		motor[L_one] = lift;
		motor[L_two] = lift;
		motor[L_Y] = lift;
		motor[R_one] = lift;
		motor[R_two] = lift;
		motor[R_Y] = lift;

	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/

task autonomous()
{

		//startTask(arms_PI);
		auton_claw = true;

	while(choice == 0)
	{
		dist(350, 127);
		claw = open;
		TurnDegree(-57,127);
		dist(750,127);
		claw = close;
		dist(150,127);
		hold = true;
		height = -400;
		TurnDegree(-130, 127);
		time_d(-700,127);
		hold = false;
		shoot(arm_up,5,true);
		claw = open;
		time_d(1450,127);
		claw = close;
		wait10Msec(80);
		hold = true;
		height = -400;
		time_d(-1400,127);
		hold = false;
		shoot(arm_up,5,true);
		claw = open;
		TurnDegree(15,127);
		time_d(1300,127);
		claw = close;
		hold = true;
		height = -400;
		time_d(-1000,127);
		hold = false;
		shoot(arm_up,5,true);
	}
	while(choice == 1)
	{
		startTask(claw_);
		dist(950,127);
		claw = close;
		dist(150,127);
		hold = true;
		height = -400;
		TurnDegree(-110, 127);
		time_d(-700,127);
		hold = false;
		shoot(arm_up,5,true);
		claw = open;
		time_d(1450,127);
		claw = close;
		wait10Msec(80);
		hold = true;
		height = -400;
		time_d(-1400,127);
		hold = false;
		shoot(arm_up,5,true);
		claw = open;
		TurnDegree(15,127);
		time_d(1300,127);
		claw = close;
		hold = true;
		height = -400;
		time_d(-1000,127);
		hold = false;
		shoot(arm_up,5,true);
	}
	while(choice == 2)
	{
		time_d(-1600,127);
		startTask(claw_);
		claw = open;
		wait10Msec(100);
		stopTask(claw_);
		shoot(arm_up-200,5,true);
		choice = 4;
	}
	while(choice == 4)
	{
		//off
	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	while (true)
	{
	height = 50;
	startTask(LCD);
	startTask(arms_PI);
	startTask(driver);
	startTask(arms);
	startTask(claw_task);

	}
}
