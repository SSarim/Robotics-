#pragma config(Sensor, in1,    GYRO,           sensorGyro)
#pragma config(Sensor, in2,    Pexpander,      sensorAnalog)
#pragma config(Sensor, in3,    ,               sensorAnalog)
#pragma config(Sensor, in4,    ,               sensorAnalog)
#pragma config(Sensor, dgtl6,  ,               sensorTouch)
#pragma config(Sensor, dgtl7,  arms_sensor,    sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  left_sensor,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, right_sensor,   sensorQuadEncoder)
#pragma config(Motor,  port1,           L_one,         tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           DR1,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           L_two,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           L_Y,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           Claw1,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           Claw2,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           R_Y,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           R_two,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           DL1,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          R_one,         tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/
bool done = false; // remove
int hold_angle = 40;
bool hold;
bool arms_returned = true;
int lift;
int i;
int turns;
int counter = 0;
int Lift_I = 0;
int Lift_hv = 20;
int height = 58;
int angle_;
int Lift_P;
bool uf_works = false;
bool works2 = false;
int step = 0;
int auton = 1;
string mainBattery, batteryTwo;
int left_drive;
int right_drive;
int x_axis;
int y_axis;
float a_value = 0.000062;
int mode = 1;
bool run_auton;
int claw = SensorValue[in1];
int claw_r ;
int claw_l;
task LCD()
{
	while(true)
	{

		if(nLCDButtons > 0)
		{
			if(mode == 1)
			{
				mode = 0;
				clearLCDLine(0);
				clearLCDLine(1);
				wait10Msec(50);
			}
			else if(mode == 0)
			{
				mode = 1;
				clearLCDLine(0);
				clearLCDLine(1);
				wait10Msec(50);

			}
		}
		if(mode == 1)
		{

			displayLCDString(0, 0, "P:");
			sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
			displayNextLCDString(mainBattery);
			displayLCDString(1, 0, "E:");
			sprintf(batteryTwo, "%1.2f%c", SensorValue[Pexpander]/280.0, 'V');    //Build the value to be displayed
			displayNextLCDString(batteryTwo);
			run_auton = false;
		}
		if(mode == 0)
		{
			clearLCDLine(0);                      // Clear line 1 (0) of the LCD
			clearLCDLine(1);
			displayLCDPos(0,0);                 // Set the cursor to line 0, position 0 (top line, far left)
			displayNextLCDString("99000B");
			displayLCDPos(1,0);                   // Set the cursor to line 1, position 0 (bottom line, far left)
			displayNextLCDString("BATTLECRUISER");
			run_auton = true;
		}
	}
}
void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	bDisplayCompetitionStatusOnLcd = false;
	clearLCDLine(0);                      // Clear line 1 (0) of the LCD
	clearLCDLine(1);                      // Clear line 2 (1) of the LCD
	bLCDBacklight = true;
	startTask(LCD);



	SensorValue[in1] = 0;
}

task gyro_direction
{
	int x = false;
	while(true)
	{
		if(motor[DL1] > 0 && x == false )
		{
			turns++;
			x = true;
		}
		else if(motor[DL1] < 0 && x == true)
		{
			turns++;
			x = false;
		}
	}
}

void gyro_turn(int angle)
{
	int motorpower = 1;
	bool turned = false;
	i = 1;
	int tol_gyro = 20;
	int counter_g;
	bool a = true;
	bool turn_count = true;
	turns = 0;
	SensorValue[in2] = sensorNone;

	while(turned == false)
	{

		if(SensorValue[in2] > angle - tol_gyro && SensorValue[in2] < angle + tol_gyro)
		{
			turns = 0;
			i = 1;
			motorpower = 0;
			turned = true;
		}
		if(motorpower < 0 && a == true)
		{
			turns++;
			a = false;
		}
		else if(motorpower > 0 && a == false)
		{
			turns++;
			a = true;
		}
		if(turns == 0)
		{
			motorpower = (SensorValue[GYRO] - angle)*2;
		}
		else
		{
			motorpower = (SensorValue[GYRO] - angle)/(turns*2.5);
		}
		motor[DR1] = motorpower + motorpower*(i/800);
		motor[DL1] = -motorpower - motorpower * (i/800);


	}
}

void drive(int dist)
{
	bool drive_a_ = true;
	SensorValue[left_sensor] = 0;
	SensorValue[right_sensor] = 0;
	int tol_da = 25;
	//while(drive_a_ == true)
	//{

	//	bool kill_loop = false;
	//	bool kill_loop_r = false;

	//	if(dist + tol_da > SensorValue[left_sensor] && dist - tol_da < SensorValue[left_sensor] && kill_loop == false)
	//	{
	//		wait10Msec(5);
	//		kill_loop = true;
	//		motor[DL1] = 0 ;
	//		motor[DL2] = 0;
	//	}
	//	else if((SensorValue[left_sensor]) < dist)
	//	{
	//		motor[DL1] = -speed;
	//		motor[DL2] = -speed;
	//	}
	//	else if((SensorValue[left_sensor]) > dist)
	//	{
	//		motor[DL1] = speed;
	//		motor[DL2] = speed;
	//	}
	//	if(dist + tol_da > SensorValue[right_sensor] && dist - tol_da < SensorValue[right_sensor] && kill_loop_r == false)
	//	{
	//		wait10Msec(5);
	//		kill_loop_r = true;
	//		motor[DR1] = 0;
	//		motor[DR2] = 0;
	//	}
	//	else if((SensorValue[right_sensor]) < dist)
	//	{
	//		motor[DR1] = -speed;
	//		motor[DR2] = -speed;
	//	}
	//	else if((SensorValue[right_sensor]) > dist)
	//	{
	//		motor[DR1] = speed;
	//		motor[DR2] = speed;
	//	}
	//	if(kill_loop == true && kill_loop_r == true)
	//	{
	//		drive_a_ = false;
	//	}
	//}
	int counter_d = 0;
	int counter_d_2 = 0;

	while(drive_a_ == true)
	{



		if(dist == -400)
		{
			SensorValue[dgtl10] = 1;
		}
		else
		{
			SensorValue[dgtl10] = 0;
		}
		if(counter_d > 150)
		{
			motor[DL1] = 0;
			motor[DR1] = 0;

			drive_a_ = false;

		}
		if(dist + tol_da > SensorValue[left_sensor] && dist - tol_da < SensorValue[left_sensor])
		{
			counter_d ++;
			counter_d_2 = 0;
		}

		else
		{
			counter_d_2 ++;
			int motorpower;
			motorpower = (SensorValue[left_sensor] - dist)* 0.55;
			if(motorpower < tol_da && motorpower > -tol_da && motorpower != 0)
			{
				motorpower = 0;
			}
			motor[DL1] = motorpower + motorpower*(counter_d_2/200);

			motor[DR1] = motorpower + motorpower*(counter_d_2/200);

		}

	}
}

void shoot(int arms, int wait)
{
	bool arms_up = false;
	bool arms_returned = false;
	while(arms_returned == false)
	{
		if(SensorValue[arms_sensor] > arms && arms_up == false)
		{

			motor[L_one] = 0;
			motor[L_two] = 0;
			motor[L_Y] = 0;
			motor[R_one] = 0;
			motor[R_two] = 0;
			motor[R_Y] = 0;
			arms_up = true;
		}

		else if(SensorValue[arms_sensor] < arms && arms_up == false)
		{
			motor[L_one] = 127;
			motor[L_two] = 127;
			motor[L_Y] = 127;
			motor[R_one] = 127;
			motor[R_two] = 127;
			motor[R_Y] = 127;
		}
		if(SensorValue[arms_sensor] > 10 &&  arms_up == true)
		{
			wait10Msec(wait);
			motor[L_one] = 0;
			motor[L_two] = 0;
			motor[L_Y] = 0;
			motor[R_one] = 0;
			motor[R_two] = 0;
			motor[R_Y] = 0;
			arms_returned = true;
		}
		else if(SensorValue[arms_sensor] < 15 && arms_up == true)
		{
			motor[L_one] = 0;
			motor[L_two] = 0;
			motor[L_Y] = 0;
			motor[R_one] = 0;
			motor[R_two] = 0;
			motor[R_Y] = 0;
			arms_returned = true;
		}
	}
}
void deploy()
{
	motor[L_one] = 55;
	motor[L_two] = 55;
	motor[L_Y] = 55;
	motor[R_one] = 55;
	motor[R_two] = 55;
	motor[R_Y] = 55;
	wait10Msec(75);
	motor[L_one] = 0;
	motor[L_two] = 0;
	motor[L_Y] = 0;
	motor[R_one] = 0;
	motor[R_two] = 0;
	motor[R_Y] = 0;
	wait10Msec(20);
	motor[L_one] = -127;
	motor[L_two] = -127;
	motor[L_Y] = -127;
	motor[R_one] = -127;
	motor[R_two] = -127;
	motor[R_Y] = -127;
	wait10Msec(400);
	motor[L_one] = 0;
	motor[L_two] =0;
	motor[L_Y] = 0;
	motor[R_one] = 0;
	motor[R_two] = 0;
	motor[R_Y] = 0;
}
//void hold_arms_temp() //temp
//{
//	bool loopback = false;
//	while(loopback == false)
//	if(SensorValue[arms_sensor] > 50 && SensorValue[arms_sensor] < 60)
//	{
//		wait10Msec(10);
//		motor[L_one] = 0;
//		motor[L_two] = 0;
//		motor[L_Y] = 0;
//		motor[R_one] = 0;
//		motor[R_two] = 0;
//		motor[R_Y] = 0;
//		loopback = true;
//	}
//	if(SensorValue[arms_sensor] < 55)
//	{
//		motor[L_one] = 60;
//		motor[L_two] = 60;
//		motor[L_Y] = 60;
//		motor[R_one] = 60;
//		motor[R_two] = 60;
//		motor[R_Y] = 60;
//	}
//	else if (SensorValue[arms_sensor] > 55)
//	{
//		motor[L_one] = -30;
//		motor[L_two] = -30;
//		motor[L_Y] = -30;
//		motor[R_one] = -30;
//		motor[R_two] = -30;
//		motor[R_Y] = -30;
//	}

//}
void arm_down()
{
	motor[L_one] = -20;
	motor[L_two] = -20;
	motor[L_Y] = -20;
	motor[R_one] = -20;
	motor[R_two] = -20;
	motor[R_Y] = -20;
	wait10Msec(50);
	motor[L_one] = 0;
	motor[L_two] = 0;
	motor[L_Y] = 0;
	motor[R_one] = 0;
	motor[R_two] = 0;
	motor[R_Y] = 0;
}
task claw_task()
{
	while (true)
	{
		claw_r = SensorValue[in3];
		claw_l = SensorValue[in4];

		if(vexRT[Btn7R] == 1)
		{
			claw -= 2;

		}
		else if(vexRT[Btn7L] == 1)
		{
			claw += 2;

		}
		else if(vexRT[Btn6U] == 1)
		{
			claw = 1700;
		}
		else if(vexRT[Btn5U] == 1)
		{
			claw = 2800;
		}
		else
		{
			claw = claw;
		}

		motor[Claw1] = (claw - claw_r)/10;
		motor[Claw2] = (claw - claw_l)/10;
	}
}
task arms_PI()
{
	counter = 0;
	Lift_P = 0;
	SensorValue[arms_sensor] = 0;
	while(true)
	{

		while(arms_returned == true && hold == true)
		{
			//Liftx = (((40 - SensorValue[arms_sensor])*100)/ 40;
			Lift_P = (1.75 * (height - SensorValue[arms_sensor]));

			if(hold == true)
			{
				lift = (20+(Lift_P));
				counter ++;

			}
			if(counter > 500)
			{
				Lift_I += 1;
				counter = 0;
			}
			motor[L_one] = lift;
			motor[L_two] = lift;
			motor[L_Y] = lift;
			motor[R_one] = lift;
			motor[R_two] = lift;
			motor[R_Y] = lift;
		}

	}
}
task driver()
{
	while(true)
	{





		x_axis = ((a_value/1.5) * (vexRT[Ch1]* vexRT[Ch1]* vexRT[Ch1]));
		y_axis = (a_value * (vexRT[Ch2]* vexRT[Ch2]* vexRT[Ch2]));

		left_drive = (y_axis - x_axis); //converts x and y axis to left motor power
		right_drive = (y_axis + x_axis);
		motor[DL1] = left_drive;
		motor[DR1] = right_drive;

	}
}
task arms()
{
	while(true)
	{

		hold = false;
		arms_returned = false;
		lift = vexRT[Ch3];
		motor[L_one] = lift;
		motor[L_two] = lift;
		motor[L_Y] = lift;
		motor[R_one] = lift;
		motor[R_two] = lift;
		motor[R_Y] = lift;

	}
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	if(run_auton == true)// decides to run auton
	{
		auton = 0;
	}
	else
	{
		auton = 0; // turns off auton
	}


	SensorValue[arms_sensor] = 0;
	if(auton == 0) // go forward and block
	{
		startTask(claw_task);
		//deploy();
		//height = 140;
		//hold = true;


		gyro_turn(600);
		gyro_turn(700);
		gyro_turn(-500);
		//claw = 2800;

	}
	if(auton == 1) //backwards shoot + block
	{
		startTask(arms_PI);
		drive(170);
		deploy();
		drive(100);
		height = 50;
		hold = true;
		//drive(400);
		hold = false;
		shoot(125, 60);
		wait10Msec(100);
		height = 160;
		hold = true;
		drive(0);
	}
	if(auton == 2) //shoot cube and block (right)
	{
		startTask(arms_PI);
		drive(-150);
		deploy();
		gyro_turn(600);
		drive(-500);
		height = 50;
		arms_returned = true;
		hold = true;
		wait10Msec(100);
		gyro_turn(1000);
		drive(400);
		hold = false;
		shoot(150,50);
		height = 140;
		arms_returned = true;
		hold = true;

	}
	if(auton == 3) //shoot cube and block (left)
	{
		drive(-400);
		deploy();
		gyro_turn(-850);
		drive(-800);
		height = 50;
		hold = true;
		drive(-100);
		gyro_turn(-950);
		drive(800);
		shoot(150,50);
		height = 140;
		hold = true;
	}
	if(auton == 4)
	{
		motor[L_one] = 80;
		motor[L_two] = 80;
		motor[L_Y] = 80;
		motor[R_one] = 80;
		motor[R_two] = 80;
		motor[R_Y] = 80;
		wait10Msec(150);
		motor[L_one] = -15;
		motor[L_two] = -15;
		motor[L_Y] = -15;
		motor[R_one] = -15;
		motor[R_two] = -15;
		motor[R_Y] = -15;
		drive(400);

	}



	//drive(-1000,80);
	//wait10Msec(90);
	//in1_turn(-1300,80);
	//drive(600,80);
	//hold = false;
	//shoot(160,50);
	//deploy();
	//SensorValue[arms_sensor] = 0;
	//drive(-600, 80);
	//hold_arms_temp();
	//in1_turn(-1000, 80);
	//drive(600, 80);
	//shoot(180,40);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	height = 50;
	startTask(LCD);
	startTask(arms_PI);
	startTask(driver);
	startTask(arms);
	startTask(claw_task);


}
